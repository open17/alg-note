---
tags:
    - 灵
    - DP
title: 从记忆化搜索到递推
date: 2024-04-10
---

基础动态规划笔记系列, 该系列部分内容会节选同步到模板中

---

:::info 内容

内容源自[灵神](https://space.bilibili.com/206214)的基础算法精讲系列  
温故而知新,复习一下
:::

## 重点

如果能够找到与原问题相似的子问题,我们就能用递归解决   

选/不选 以及 选那些的思路去缩小问题的范围

而所谓DP,本质上就是带备忘录的递归算法  

要注意: $dp_i$的定义是一些元素算得的结果

:::info 一些变化
对于回溯，通常是在「递」的过程中增量地构建答案，并在失败时能够回退，例如八皇后。对于递归，是把原问题分解为若干个相似的子问题，通常会在「归」的过程中有一些计算。如果一个递归能考虑用记忆化来优化，就需要 return 一个值并加以保存。
:::  

时间复杂度计算: 状态个数*单个状态所需的时间  

转为递推? 

- 确定边界
- 自树底向上

为什么要转为dp?

两者可视为手动挡和自动挡,自动挡虽然方便,但是灵活性不如手动挡(递推dp)

比如递推形式可以滚动数组优化,可以加入各种各样的数据结构优化


## 例题

:::code-group

<<< @/../code/LeetCode/198[记忆化].py

<<< @/../code/LeetCode/198[dp].py 

<<< @/../code/LeetCode/198[滚动数组].py

:::

## 练习

### 70. 爬楼梯

<<< @/../code/LeetCode/70.py



### 746. 使用最小花费爬楼梯

<<< @/../code/LeetCode/746.py

### 377. 组合总和

<<< @/../code/LeetCode/377.py

### 2466. 统计构造好字符串的方案数

有意思的题,要发现贡献本质

:::details 错误写法
```py
class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        MOD=int(1e9)+7
        @cache
        def f(s):
            if len(s)>high:
                return 0
            res=int(low<=len(s)<=high)
            return res+(f(s+"0"*zero)%MOD+f(s+"1"*one)%MOD)%MOD
        return f("")
```
:::

<<< @/../code/LeetCode/2466[DP][思维].py

### 740. 删除并获得点数

<<< @/../code/LeetCode/740[DP][哈希表].py

### 2320. 统计放置房子的方式数

<<< @/../code/LeetCode/2320[DP].py

### 213. 打家劫舍 II

分类讨论拆环

<<< @/../code/LeetCode/213[DP][拆环].py

### LCR 166. 珠宝的最高价值

<<< @/../code/LeetCode/LCR166[DP][网格DP].py